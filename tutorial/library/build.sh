#!/usr/bin/env bash
#
# build.sh - Build the CLI into a single distributable file
#
# This script:
# 1. Reads all command schemas from src/commands/*/schema.json
# 2. Embeds all core modules
# 3. Generates register_arg/register_command calls from JSON
# 4. Outputs a single dist/cli.sh file
#

set -o errexit
set -o nounset
set -o pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SRC_DIR="${SCRIPT_DIR}/src"
DIST_DIR="${SCRIPT_DIR}/dist"
OUTPUT_FILE="${DIST_DIR}/cli.sh"

# ────────────────────────────────────────────────────────────────
# Simple JSON parsing (no jq dependency)
# ────────────────────────────────────────────────────────────────

# Extract a simple string value from JSON: json_get '{"name": "foo"}' "name" -> foo
json_get() {
    local json="$1"
    local key="$2"
    local default="${3:-}"

    # Match "key": "value" or "key": value (for booleans/numbers)
    local result
    result=$(echo "${json}" | grep -oP "\"${key}\"\\s*:\\s*\"?\\K[^\",}]+" | head -1) || true

    if [[ -z "${result}" ]]; then
        echo "${default}"
    else
        echo "${result}"
    fi
}

# Parse schema.json and output register_arg/register_command calls
parse_schema() {
    local schema_file="$1"
    local json
    json=$(tr -d '\n\r' < "${schema_file}")

    # Get command name and description
    local cmd_name cmd_desc
    cmd_name=$(json_get "${json}" "name")
    cmd_desc=$(json_get "${json}" "description")

    # Extract args array content
    local args_section
    args_section=$(echo "${json}" | grep -oP '"args"\s*:\s*\[\K[^\]]*' || echo "")

    # Parse each arg object
    if [[ -n "${args_section}" ]]; then
        # Split by }, and process each arg
        local IFS='}'
        local arg_objects
        read -ra arg_objects <<< "${args_section}"

        for arg_obj in "${arg_objects[@]}"; do
            # Skip empty
            [[ -z "${arg_obj//[[:space:],\[]/}" ]] && continue

            local arg_name arg_short arg_type arg_required arg_default arg_help
            arg_name=$(json_get "${arg_obj}" "name")
            arg_short=$(json_get "${arg_obj}" "short" "")
            arg_type=$(json_get "${arg_obj}" "type" "string")
            arg_required=$(json_get "${arg_obj}" "required" "false")
            arg_default=$(json_get "${arg_obj}" "default" "")
            arg_help=$(json_get "${arg_obj}" "help" "")

            [[ -z "${arg_name}" ]] && continue

            echo "register_arg \"${arg_name}\" \"${arg_short}\" \"${arg_type}\" \"${arg_required}\" \"${arg_default}\" \"${arg_help}\" \"${cmd_name}\""
        done
    fi

    # Output register_command
    echo "register_command \"${cmd_name}\" \"${cmd_desc}\""
}

# ────────────────────────────────────────────────────────────────
# Build Process
# ────────────────────────────────────────────────────────────────

# Ensure dist directory exists
mkdir -p "${DIST_DIR}"

# Start building the output file
cat > "${OUTPUT_FILE}" << 'HEADER'
#!/usr/bin/env bash
#
# cli.sh - CLI Framework (Built Distribution)
#
# This is an auto-generated file. Do not edit directly.
# Generated by build.sh
#

HEADER

# Add generation timestamp
echo "# Built: $(date -u '+%Y-%m-%dT%H:%M:%SZ')" >> "${OUTPUT_FILE}"
echo "" >> "${OUTPUT_FILE}"

# ────────────────────────────────────────────────────────────────
# Embed core modules
# ────────────────────────────────────────────────────────────────

embed_module() {
    local file="$1"
    local name
    name=$(basename "${file}" .sh)

    echo "" >> "${OUTPUT_FILE}"
    echo "# ════════════════════════════════════════════════════════════════" >> "${OUTPUT_FILE}"
    echo "# Module: ${name}" >> "${OUTPUT_FILE}"
    echo "# ════════════════════════════════════════════════════════════════" >> "${OUTPUT_FILE}"
    echo "" >> "${OUTPUT_FILE}"

    # Strip shebang line and write content
    tail -n +2 "${file}" >> "${OUTPUT_FILE}"
}

echo "Embedding core modules..."
embed_module "${SRC_DIR}/core/errors.sh"
embed_module "${SRC_DIR}/core/portability.sh"
embed_module "${SRC_DIR}/core/validation.sh"
embed_module "${SRC_DIR}/core/flags.sh"
embed_module "${SRC_DIR}/core/logging.sh"

# ────────────────────────────────────────────────────────────────
# Add CLI framework code
# ────────────────────────────────────────────────────────────────

cat >> "${OUTPUT_FILE}" << 'CLI_FRAMEWORK'

# ════════════════════════════════════════════════════════════════
# CLI Framework
# ════════════════════════════════════════════════════════════════

# Get the directory where this script lives
__CLI_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
__CLI_NAME="$(basename "${BASH_SOURCE[0]}" .sh)"
__CLI_VERSION="1.0.0"

# Enable strict mode
enable_strict_mode

# Verify shell compatibility
verify_shell

# ────────────────────────────────────────────────────────────────
# Command Registry
# ────────────────────────────────────────────────────────────────

declare -A __COMMAND_REGISTRY=()
declare -A __COMMAND_HELP=()

# Register a command with its handler and help text
register_command() {
    local name="$1"
    local help="${2:-}"
    local handler="${3:-cmd_${name}}"

    __COMMAND_REGISTRY["${name}"]="${handler}"
    __COMMAND_HELP["${name}"]="${help}"
}

# Check if command exists
command_exists() {
    local name="$1"
    [[ -n "${__COMMAND_REGISTRY[${name}]:-}" ]]
}

# Get command handler
get_command_handler() {
    local name="$1"
    echo "${__COMMAND_REGISTRY[${name}]:-}"
}

# List all registered commands
list_commands() {
    printf '%s\n' "${!__COMMAND_REGISTRY[@]}" | sort
}

# ────────────────────────────────────────────────────────────────
# Help System
# ────────────────────────────────────────────────────────────────

show_version() {
    echo "${__CLI_NAME} version ${__CLI_VERSION}"
}

show_help() {
    local command="${1:-}"

    if [[ -n "${command}" ]] && command_exists "${command}"; then
        show_command_help "${command}"
    else
        show_global_help
    fi
}

show_global_help() {
    cat <<EOF
${__CLI_NAME} - A shell CLI framework

Usage:
  ${__CLI_NAME} <command> [options] [arguments]
  ${__CLI_NAME} [global-options]

Commands:
EOF

    local cmd
    for cmd in $(list_commands); do
        printf "  %-20s %s\n" "${cmd}" "${__COMMAND_HELP[${cmd}]:-}"
    done

    cat <<EOF

Global Options:
EOF
    generate_flag_help "global"

    cat <<EOF

Run '${__CLI_NAME} <command> --help' for command-specific help.
EOF
}

show_command_help() {
    local command="$1"
    local help="${__COMMAND_HELP[${command}]:-No description available}"

    cat <<EOF
${__CLI_NAME} ${command} - ${help}

Usage:
  ${__CLI_NAME} ${command} [options] [arguments]

Options:
EOF
    generate_flag_help "${command}"
}

# ────────────────────────────────────────────────────────────────
# Command Dispatch
# ────────────────────────────────────────────────────────────────

dispatch() {
    local command="${1:-}"
    shift || true

    if [[ -z "${command}" ]]; then
        show_global_help
        exit 0
    fi

    case "${command}" in
        --help|-h)
            show_global_help
            exit 0
            ;;
        --version|-V)
            show_version
            exit 0
            ;;
    esac

    if ! command_exists "${command}"; then
        log_error "Unknown command: ${command}"
        echo ""
        show_global_help
        exit "${EXIT_USAGE}"
    fi

    parse_args "${command}" "$@"
    configure_logging_from_flags

    if is_flag_true "help"; then
        show_command_help "${command}"
        exit 0
    fi

    local handler
    handler=$(get_command_handler "${command}")

    if ! type "${handler}" >/dev/null 2>&1; then
        die_internal "Handler '${handler}' for command '${command}' not found"
    fi

    log_debug "Executing command: ${command}"
    "${handler}"
}

# ────────────────────────────────────────────────────────────────
# Built-in Commands
# ────────────────────────────────────────────────────────────────

cmd_help() {
    local topic
    topic=$(get_positional 0 "")
    show_help "${topic}"
}

cmd_version() {
    show_version
}

cmd_commands() {
    echo "Available commands:"
    local cmd
    for cmd in $(list_commands); do
        printf "  %-20s %s\n" "${cmd}" "${__COMMAND_HELP[${cmd}]:-}"
    done
}

register_command "help" "Show help information"
register_command "version" "Show version information"
register_command "commands" "List available commands"

CLI_FRAMEWORK

# ────────────────────────────────────────────────────────────────
# Process command schemas
# ────────────────────────────────────────────────────────────────

echo "" >> "${OUTPUT_FILE}"
echo "# ════════════════════════════════════════════════════════════════" >> "${OUTPUT_FILE}"
echo "# Command Registrations (generated from schema.json files)" >> "${OUTPUT_FILE}"
echo "# ════════════════════════════════════════════════════════════════" >> "${OUTPUT_FILE}"
echo "" >> "${OUTPUT_FILE}"

for cmd_dir in "${SRC_DIR}"/commands/*/; do
    [[ -d "${cmd_dir}" ]] || continue

    schema_file="${cmd_dir}schema.json"
    main_file="${cmd_dir}main.sh"

    if [[ ! -f "${schema_file}" ]]; then
        echo "Warning: No schema.json in ${cmd_dir}, skipping" >&2
        continue
    fi

    if [[ ! -f "${main_file}" ]]; then
        echo "Warning: No main.sh in ${cmd_dir}, skipping" >&2
        continue
    fi

    # Get command name for display
    cmd_name=$(json_get "$(cat "${schema_file}")" "name")
    echo "Processing command: ${cmd_name}"

    echo "" >> "${OUTPUT_FILE}"
    echo "# ────────────────────────────────────────────────────────────────" >> "${OUTPUT_FILE}"
    echo "# Command: ${cmd_name}" >> "${OUTPUT_FILE}"
    echo "# ────────────────────────────────────────────────────────────────" >> "${OUTPUT_FILE}"
    echo "" >> "${OUTPUT_FILE}"

    # Generate registrations from schema
    parse_schema "${schema_file}" >> "${OUTPUT_FILE}"
    echo "" >> "${OUTPUT_FILE}"

    # Embed command handler
    tail -n +2 "${main_file}" >> "${OUTPUT_FILE}"
done

# ────────────────────────────────────────────────────────────────
# Add main entry point
# ────────────────────────────────────────────────────────────────

cat >> "${OUTPUT_FILE}" << 'MAIN_ENTRY'

# ════════════════════════════════════════════════════════════════
# Main Entry Point
# ════════════════════════════════════════════════════════════════

main() {
    dispatch "$@"
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    main "$@"
fi
MAIN_ENTRY

chmod +x "${OUTPUT_FILE}"

echo ""
echo "Build complete: ${OUTPUT_FILE}"
echo "File size: $(wc -c < "${OUTPUT_FILE}") bytes"
